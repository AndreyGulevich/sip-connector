import { assign, setup } from 'xstate';

import { BaseStateMachine } from '@/tools/BaseStateMachine';
import hasPurgatory from '@/tools/hasPurgatory';

import type { TApiManagerEvents } from '@/ApiManager';
import type { TEvents } from './events';

export enum EState {
  IDLE = 'call:idle',
  CONNECTING = 'call:connecting',
  PURGATORY = 'call:purgatory',
  IN_ROOM = 'call:inRoom',
}

// eslint-disable-next-line @typescript-eslint/no-empty-object-type
type TIdleContext = {};
type TConnectingContext = {
  number: string;
  answer: boolean;
};

export type TPurgatoryContext = TConnectingContext & {
  room: string;
  participantName: string;
};

export type TInRoomContext = TConnectingContext & {
  room: string;
  participantName: string;
  token: string; // jwt
  conference: string;
  participant: string;
};

type TContext = TIdleContext | TConnectingContext | TPurgatoryContext | TInRoomContext;

type TCallEvent =
  | { type: 'CALL.CONNECTING'; number: string; answer: boolean }
  | { type: 'CALL.ENTER_ROOM'; room: string; participantName: string; token?: string }
  | { type: 'CALL.TOKEN_ISSUED'; token: string }
  | { type: 'CALL.RESET' };

const EVALUATE = 'evaluate' as const;

const isNonEmptyString = (value?: string): value is string => {
  return typeof value === 'string' && value.length > 0;
};

const hasConnectingContext = (context: TContext): context is TConnectingContext => {
  return (
    'number' in context && isNonEmptyString(context.number) && typeof context.answer === 'boolean'
  );
};

const hasRoomContext = (context: TContext) => {
  return (
    'room' in context && isNonEmptyString(context.room) && isNonEmptyString(context.participantName)
  );
};

const hasTokenContext = (context: TContext) => {
  return 'token' in context && isNonEmptyString(context.token);
};

const hasPurgatoryContext = (context: TContext): context is TPurgatoryContext => {
  return (
    hasConnectingContext(context) &&
    hasRoomContext(context) &&
    !hasTokenContext(context) &&
    'room' in context &&
    hasPurgatory(context.room)
  );
};

const hasInRoomContext = (context: TContext): context is TInRoomContext => {
  return hasConnectingContext(context) && hasRoomContext(context) && hasTokenContext(context);
};

const initialContext: TIdleContext = {};

const clearCallContext = (): Partial<TContext> => {
  return {
    number: undefined,
    answer: undefined,
    room: undefined,
    participantName: undefined,
    token: undefined,
  };
};

const callMachine = setup({
  types: {
    context: initialContext as TContext,
    events: {} as TCallEvent,
  },
  actions: {
    setConnecting: assign(({ event, context }) => {
      if (event.type !== 'CALL.CONNECTING') {
        return context;
      }

      return {
        ...clearCallContext(),
        number: event.number,
        answer: event.answer,
      };
    }),
    setRoomInfo: assign(({ event, context }) => {
      if (event.type !== 'CALL.ENTER_ROOM') {
        return context;
      }

      const nextContext: Partial<TInRoomContext> = {
        room: event.room,
        participantName: event.participantName,
      };

      if (event.token !== undefined) {
        nextContext.token = event.token;
      } else if (hasPurgatory(event.room)) {
        nextContext.token = undefined;
      }

      return nextContext;
    }),
    setTokenInfo: assign(({ event, context }) => {
      if (event.type !== 'CALL.TOKEN_ISSUED') {
        return context;
      }

      return {
        token: event.token,
      };
    }),
    reset: assign(clearCallContext()),
  },
}).createMachine({
  id: 'call',
  initial: EState.IDLE,
  context: {},
  states: {
    [EState.IDLE]: {
      on: {
        'CALL.CONNECTING': {
          target: EVALUATE,
          actions: 'setConnecting',
        },
      },
    },
    [EState.CONNECTING]: {
      on: {
        'CALL.ENTER_ROOM': {
          target: EVALUATE,
          actions: 'setRoomInfo',
        },
        'CALL.TOKEN_ISSUED': {
          target: EVALUATE,
          actions: 'setTokenInfo',
        },
        'CALL.RESET': {
          target: EVALUATE,
          actions: 'reset',
        },
      },
    },
    [EState.IN_ROOM]: {
      on: {
        'CALL.ENTER_ROOM': {
          target: EVALUATE,
          actions: 'setRoomInfo',
        },
        'CALL.TOKEN_ISSUED': {
          target: EVALUATE,
          actions: 'setTokenInfo',
        },
        'CALL.RESET': {
          target: EVALUATE,
          actions: 'reset',
        },
      },
    },
    [EVALUATE]: {
      always: [
        {
          target: EState.IN_ROOM,
          guard: ({ context }) => {
            return hasInRoomContext(context);
          },
        },
        {
          target: EState.PURGATORY,
          guard: ({ context }) => {
            return hasPurgatoryContext(context);
          },
        },
        {
          target: EState.CONNECTING,
          guard: ({ context }) => {
            return hasConnectingContext(context);
          },
        },
        {
          target: EState.IDLE,
        },
      ],
    },
    [EState.PURGATORY]: {
      on: {
        'CALL.ENTER_ROOM': {
          target: EVALUATE,
          actions: 'setRoomInfo',
        },
        'CALL.TOKEN_ISSUED': {
          target: EVALUATE,
          actions: 'setTokenInfo',
        },
        'CALL.RESET': {
          target: EVALUATE,
          actions: 'reset',
        },
      },
    },
  },
});

export type TCallSnapshot = { value: EState; context: TContext };

export class CallStateMachine extends BaseStateMachine<typeof callMachine, EState, TContext> {
  public constructor(events: TEvents) {
    super(callMachine);

    this.subscribeToEvents(events);
  }

  public get isIdle(): boolean {
    return this.state === EState.IDLE;
  }

  public get isConnecting(): boolean {
    return this.state === EState.CONNECTING;
  }

  public get isInPurgatory(): boolean {
    return this.state === EState.PURGATORY;
  }

  public get isInRoom(): boolean {
    return this.state === EState.IN_ROOM;
  }

  /** Контекст в состоянии IN_ROOM; undefined в остальных состояниях. Использовать вместо каста context. */
  public get inRoomContext(): TInRoomContext | undefined {
    const { context } = this;

    return hasInRoomContext(context) ? context : undefined;
  }

  public get isActive(): boolean {
    return this.isInRoom || this.isInPurgatory;
  }

  public get isPending(): boolean {
    return this.isConnecting;
  }

  public get number() {
    const { context } = this;

    if ('number' in context) {
      return context.number;
    }

    return undefined;
  }

  public get token() {
    const { context } = this;

    if ('token' in context) {
      return context.token;
    }

    return undefined;
  }

  public reset(): void {
    this.send({ type: 'CALL.RESET' });
  }

  public send(event: TCallEvent): void {
    const snapshot = this.actor.getSnapshot();

    if (!snapshot.can(event)) {
      // eslint-disable-next-line no-console
      console.warn(
        `[CallStateMachine] Invalid transition: ${event.type} from ${this.state}. Event cannot be processed in current state.`,
      );

      return;
    }

    super.send(event);
  }

  public subscribeToApiEvents(apiManager: TApiManagerEvents): void {
    this.addSubscription(
      apiManager.on('enter-room', ({ room, participantName, bearerToken }) => {
        this.send({ type: 'CALL.ENTER_ROOM', room, participantName, token: bearerToken });
      }),
    );
    this.addSubscription(
      apiManager.on('conference:participant-token-issued', ({ jwt: token }) => {
        this.send({ type: 'CALL.TOKEN_ISSUED', token });
      }),
    );
  }

  private subscribeToEvents(events: TEvents) {
    this.addSubscription(
      events.on('start-call', ({ number, answer }) => {
        this.send({ type: 'CALL.CONNECTING', number, answer });
      }),
    );

    this.addSubscription(
      events.on('ended', () => {
        this.send({ type: 'CALL.RESET' });
      }),
    );
    this.addSubscription(
      events.on('failed', () => {
        this.send({ type: 'CALL.RESET' });
      }),
    );
  }
}
